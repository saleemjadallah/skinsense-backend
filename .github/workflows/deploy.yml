name: Deploy to EC2

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Create deployment package
      run: |
        # Debug: Show current directory and files
        echo "Current directory: $(pwd)"
        echo "Files in repository root:"
        ls -la
        echo "Checking if app directory exists:"
        [ -d app ] && echo "app directory found" || echo "ERROR: app directory not found!"
        
        mkdir -p deployment
        # Copy files with error checking
        echo "Copying app directory..."
        cp -r app deployment/ || { echo "ERROR: Failed to copy app directory"; exit 1; }
        
        echo "Copying scripts directory..."
        cp -r scripts deployment/ 2>/dev/null || mkdir -p deployment/scripts
        
        echo "Copying requirements.txt..."
        cp requirements.txt deployment/ || { echo "ERROR: Failed to copy requirements.txt"; exit 1; }
        
        echo "Copying Dockerfile..."
        cp Dockerfile deployment/ || { echo "ERROR: Failed to copy Dockerfile"; exit 1; }
        
        echo "Copying docker-compose.yml..."
        cp docker-compose.yml deployment/ || { echo "ERROR: Failed to copy docker-compose.yml"; exit 1; }
        
        echo "Copying nginx.conf if exists..."
        cp nginx.conf deployment/ 2>/dev/null || echo "nginx.conf not found, skipping"
        
        echo "Copying .dockerignore if exists..."
        cp .dockerignore deployment/ 2>/dev/null || echo ".dockerignore not found, creating default"
        [ ! -f deployment/.dockerignore ] && echo "__pycache__\n*.pyc\n.env\n.git" > deployment/.dockerignore
        
        # Create .env file
        cat > deployment/.env << EOF
        APP_NAME="SkinSense AI"
        APP_VERSION="1.0.0"
        DEBUG=false
        MONGODB_URL=${{ secrets.MONGODB_URL }}
        DATABASE_NAME=skinpal
        REDIS_URL=redis://redis:6379
        SECRET_KEY=${{ secrets.SECRET_KEY }}
        ALGORITHM=HS256
        ACCESS_TOKEN_EXPIRE_MINUTES=60
        REFRESH_TOKEN_EXPIRE_DAYS=30
        ORBO_AI_API_KEY=${{ secrets.ORBO_AI_API_KEY }}
        ORBO_API_KEY=${{ secrets.ORBO_AI_API_KEY }}
        ORBO_CLIENT_ID=${{ secrets.ORBO_CLIENT_ID }}
        ORBO_CLIENTID=${{ secrets.ORBO_CLIENT_ID }}
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        PERPLEXITY_API_KEY=${{ secrets.PERPLEXITY_API_KEY }}
        AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION=${{ secrets.AWS_REGION }}
        S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}
        CLOUDFRONT_DOMAIN=${{ secrets.CLOUDFRONT_DOMAIN }}
        ZEPTOMAIL_SEND_TOKEN=${{ secrets.ZEPTOMAIL_SEND_TOKEN }}
        EOF
        
        # Create Firebase credentials if provided
        if [ ! -z "${{ secrets.FIREBASE_SERVICE_ACCOUNT }}" ]; then
          mkdir -p deployment/credentials
          echo "${{ secrets.FIREBASE_SERVICE_ACCOUNT }}" | base64 -d > deployment/credentials/firebase-service-account.json
        fi
        
        # Debug: Check deployment directory contents
        echo "Deployment directory contents:"
        ls -la deployment/
        
        # Create tarball with error checking
        echo "Creating deployment tarball..."
        tar -czf deployment.tar.gz -C deployment . || {
          echo "ERROR: Failed to create tar archive!"
          exit 1
        }
        
        # Verify tarball was created and has content
        if [ ! -f deployment.tar.gz ]; then
          echo "ERROR: deployment.tar.gz was not created!"
          exit 1
        fi
        
        TAR_SIZE=$(stat -f%z deployment.tar.gz 2>/dev/null || stat -c%s deployment.tar.gz 2>/dev/null || echo "0")
        echo "Deployment package size: $TAR_SIZE bytes"
        
        if [ "$TAR_SIZE" -eq "0" ]; then
          echo "ERROR: deployment.tar.gz is empty!"
          echo "Checking what went wrong:"
          ls -la
          echo "Deployment directory:"
          ls -la deployment/
          exit 1
        fi
        
        # List contents of tarball for verification
        echo "Tarball contents:"
        tar -tzf deployment.tar.gz | head -20
    
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_KEY }}" | base64 -d > ~/.ssh/ec2_key.pem
        chmod 600 ~/.ssh/ec2_key.pem
        ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
    
    - name: Copy and Deploy to EC2
      run: |
        # Copy deployment package
        echo "ðŸ“¦ Copying deployment package to EC2..."
        scp -i ~/.ssh/ec2_key.pem deployment.tar.gz ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:~/deployment.tar.gz
        
        # Verify copy was successful
        ssh -i ~/.ssh/ec2_key.pem ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "ls -la ~/deployment.tar.gz"
        
        # Deploy with zero downtime
        ssh -i ~/.ssh/ec2_key.pem ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENDSSH'
        set -e
        
        echo "ðŸš€ Starting zero-downtime deployment..."
        
        # Debug: Check current directory and files
        echo "Current directory: $(pwd)"
        echo "Home directory contents:"
        ls -la ~/ | grep deployment || echo "No deployment files found"
        
        # Verify deployment package exists
        if [ ! -f ~/deployment.tar.gz ]; then
          echo "âŒ Deployment package not found in home directory!"
          echo "Checking current directory:"
          ls -la
          exit 1
        fi
        
        # Constants
        PROJECT_NAME="skinsense-backend"
        DEPLOY_DIR="$HOME/skinsense-backend"
        NEW_DIR="$HOME/skinsense-backend-new"
        
        # Extract new deployment
        mkdir -p $NEW_DIR
        cd $NEW_DIR
        echo "ðŸ“¦ Extracting deployment package..."
        tar -xzf ~/deployment.tar.gz
        
        # Verify extraction
        if [ ! -f docker-compose.yml ]; then
          echo "âŒ docker-compose.yml not found after extraction!"
          ls -la
          exit 1
        fi
        
        rm ~/deployment.tar.gz
        
        # Build new images
        echo "ðŸ“¦ Building new Docker images..."
        docker-compose build --quiet
        
        # Check if old deployment exists
        if [ -d "$DEPLOY_DIR" ] && docker ps | grep -q "$PROJECT_NAME"; then
          echo "ðŸ”„ Performing rolling update..."
          
          # Start new containers with green suffix
          docker-compose -p ${PROJECT_NAME}-green up -d
          
          # Wait for new containers to be healthy
          echo "â³ Waiting for new containers to be healthy..."
          sleep 30
          
          # Check health of new deployment
          if docker exec ${PROJECT_NAME}-green-api-1 curl -s http://localhost:8000/health > /dev/null 2>&1; then
            echo "âœ… New deployment is healthy!"
            
            # Stop old deployment
            cd $DEPLOY_DIR 2>/dev/null && docker-compose -p $PROJECT_NAME stop --timeout 30 || true
            cd $DEPLOY_DIR 2>/dev/null && docker-compose -p $PROJECT_NAME rm -f || true
            
            # Switch directories
            mv $DEPLOY_DIR ${DEPLOY_DIR}-old-$(date +%s) 2>/dev/null || true
            mv $NEW_DIR $DEPLOY_DIR
            
            # Restart with production name
            cd $DEPLOY_DIR
            docker-compose -p ${PROJECT_NAME}-green stop
            docker-compose -p ${PROJECT_NAME}-green rm -f
            docker-compose -p $PROJECT_NAME up -d
            
            echo "âœ… Rolling update complete!"
          else
            echo "âŒ New deployment failed health check, keeping old deployment..."
            docker-compose -p ${PROJECT_NAME}-green down
            rm -rf $NEW_DIR
            exit 1
          fi
        else
          echo "ðŸ“¦ Fresh deployment..."
          
          # No existing deployment, start fresh
          mv $DEPLOY_DIR ${DEPLOY_DIR}-old-$(date +%s) 2>/dev/null || true
          mv $NEW_DIR $DEPLOY_DIR
          cd $DEPLOY_DIR
          
          docker-compose -p $PROJECT_NAME up -d
          
          # Wait and check health
          sleep 30
          if curl -s http://localhost:8000/health > /dev/null 2>&1; then
            echo "âœ… Fresh deployment successful!"
          else
            echo "âš ï¸ Health check failed but containers may still be starting..."
          fi
        fi
        
        # Cleanup
        docker system prune -f > /dev/null 2>&1
        rm -rf ${DEPLOY_DIR}-old-* 2>/dev/null || true
        
        # Show final status
        echo ""
        echo "ðŸ“Š Deployment Status:"
        docker ps | grep $PROJECT_NAME || docker ps
        echo ""
        echo "ðŸŽ‰ Deployment complete!"
        echo "API: http://${{ secrets.EC2_HOST }}:8000"
        echo "Docs: http://${{ secrets.EC2_HOST }}:8000/docs"
        ENDSSH
    
    - name: Cleanup
      if: always()
      run: |
        rm -f ~/.ssh/ec2_key.pem deployment.tar.gz
        rm -rf deployment/