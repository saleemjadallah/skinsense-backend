name: Deploy to EC2

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Create deployment package
      run: |
        # Create temporary directory
        mkdir -p deployment
        
        # Copy necessary files
        cp -r app deployment/
        cp -r scripts deployment/ 2>/dev/null || mkdir -p deployment/scripts
        cp requirements.txt deployment/
        cp Dockerfile deployment/
        cp docker-compose.yml deployment/  # IMPORTANT: Copy docker-compose.yml
        cp docker-compose.prod.yml deployment/ 2>/dev/null || true
        cp .dockerignore deployment/
        
        # Create .env file with production secrets
        cat > deployment/.env << EOF
        APP_NAME="SkinSense AI"
        APP_VERSION="1.0.0"
        DEBUG=false
        MONGODB_URL=${{ secrets.MONGODB_URL }}
        DATABASE_NAME=skinpal
        REDIS_URL=redis://redis:6379
        SECRET_KEY=${{ secrets.SECRET_KEY }}
        ALGORITHM=HS256
        ACCESS_TOKEN_EXPIRE_MINUTES=60
        REFRESH_TOKEN_EXPIRE_DAYS=30
        ORBO_AI_API_KEY=${{ secrets.ORBO_AI_API_KEY }}
        ORBO_API_KEY=${{ secrets.ORBO_AI_API_KEY }}
        ORBO_CLIENT_ID=${{ secrets.ORBO_CLIENT_ID }}
        ORBO_CLIENTID=${{ secrets.ORBO_CLIENT_ID }}
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        PERPLEXITY_API_KEY=${{ secrets.PERPLEXITY_API_KEY }}
        AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION=${{ secrets.AWS_REGION }}
        S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}
        CLOUDFRONT_DOMAIN=${{ secrets.CLOUDFRONT_DOMAIN }}
        ZEPTOMAIL_SEND_TOKEN=${{ secrets.ZEPTOMAIL_SEND_TOKEN }}
        ZEPTOMAIL_HOST=api.zeptomail.com
        ZEPTOMAIL_DOMAIN=skinsense.app
        FIREBASE_PROJECT_ID=${{ secrets.FIREBASE_PROJECT_ID }}
        FIREBASE_SERVICE_ACCOUNT_PATH=/app/credentials/firebase-service-account.json
        PROMETHEUS_URL=http://prometheus:9090
        GRAFANA_URL=http://grafana:3001
        EOF
        
        # Create Firebase credentials if provided
        if [ ! -z "${{ secrets.FIREBASE_SERVICE_ACCOUNT }}" ]; then
          mkdir -p deployment/credentials
          echo "${{ secrets.FIREBASE_SERVICE_ACCOUNT }}" | base64 -d > deployment/credentials/firebase-service-account.json
        fi
        
        # Create tarball
        tar -czf deployment.tar.gz -C deployment .
    
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        
        # Decode EC2 key with error handling
        echo "${{ secrets.EC2_KEY }}" | base64 -d > ~/.ssh/ec2_key.pem 2>/dev/null || {
          echo "‚ùå Failed to decode EC2_KEY. Make sure it's properly base64 encoded."
          echo "To encode your key: base64 -i your-key.pem | tr -d '\n'"
          exit 1
        }
        
        chmod 600 ~/.ssh/ec2_key.pem
        ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
    
    - name: Copy deployment package to EC2
      run: |
        scp -i ~/.ssh/ec2_key.pem deployment.tar.gz ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:~/
    
    - name: Deploy on EC2 with Docker Compose (with fallback)
      run: |
        ssh -i ~/.ssh/ec2_key.pem ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENDSSH'
        echo "üöÄ Starting deployment..."
        
        # AGGRESSIVE CLEANUP - Nuclear option for ContainerConfig error
        echo "üî• NUCLEAR CLEANUP - Removing everything Docker-related..."
        
        # Step 1: Kill all Docker processes
        echo "Step 1: Killing Docker processes..."
        sudo pkill -9 docker 2>/dev/null || true
        sleep 2
        
        # Step 2: Restart Docker daemon
        echo "Step 2: Restarting Docker daemon..."
        sudo systemctl restart docker
        sleep 5
        
        # Step 3: Remove EVERYTHING
        echo "Step 3: Removing all containers, images, volumes, networks..."
        docker kill $(docker ps -q) 2>/dev/null || true
        docker rm -f $(docker ps -aq) 2>/dev/null || true
        docker rmi -f $(docker images -aq) 2>/dev/null || true
        docker volume rm -f $(docker volume ls -q) 2>/dev/null || true
        docker network prune -f 2>/dev/null || true
        docker system prune -af --volumes 2>/dev/null || true
        
        # Step 4: Clean Docker directory (careful!)
        echo "Step 4: Cleaning Docker directories..."
        sudo rm -rf /var/lib/docker/containers/* 2>/dev/null || true
        sudo rm -rf /var/lib/docker/volumes/* 2>/dev/null || true
        sudo systemctl restart docker
        sleep 5
        
        # Backup old deployment
        if [ -d ~/skinsense-backend ]; then
          mv ~/skinsense-backend ~/skinsense-backend.backup.$(date +%Y%m%d_%H%M%S)
        fi
        
        # Create new deployment directory
        mkdir -p ~/skinsense-backend
        cd ~/skinsense-backend
        
        # Extract deployment package
        tar -xzf ~/deployment.tar.gz
        rm ~/deployment.tar.gz
        
        # Verify docker-compose.yml exists
        if [ ! -f docker-compose.yml ]; then
          echo "‚ùå docker-compose.yml not found!"
          exit 1
        fi
        
        echo "‚úÖ docker-compose.yml found"
        
        # Try docker-compose first
        echo "üî® Attempting deployment with docker-compose..."
        if docker-compose up -d --build --force-recreate --remove-orphans 2>&1; then
          echo "‚úÖ Docker Compose deployment successful!"
          sleep 10
          docker-compose ps
          docker-compose logs --tail=50
        else
          echo "‚ö†Ô∏è Docker Compose failed, falling back to plain Docker..."
          
          # FALLBACK: Use plain Docker commands
          echo "üîÑ Using plain Docker commands as fallback..."
          
          # Build the image
          docker build -t skinsense-api:latest .
          
          # Start Redis
          docker run -d \
            --name skinsense_redis \
            --restart always \
            -p 6379:6379 \
            redis:7-alpine
          
          # Wait for Redis
          sleep 3
          
          # Start API
          docker run -d \
            --name skinsense_api \
            --restart always \
            -p 8000:8000 \
            --link skinsense_redis:redis \
            -e REDIS_URL=redis://skinsense_redis:6379 \
            --env-file .env \
            skinsense-api:latest
          
          echo "‚úÖ Plain Docker deployment completed!"
          sleep 10
          docker ps
          docker logs skinsense_api --tail=50
        fi
        
        # Health check
        if curl -f http://localhost:8000/health; then
          echo "‚úÖ Health check passed!"
          echo "üéâ Deployment successful!"
        else
          echo "‚ùå Health check failed. Checking logs..."
          docker ps -a
          docker logs skinsense_api --tail=100 2>/dev/null || docker-compose logs --tail=100
          exit 1
        fi
        ENDSSH
    
    - name: Clean up
      if: always()
      run: |
        rm -f ~/.ssh/ec2_key.pem
        rm -f deployment.tar.gz
        rm -rf deployment/
    
    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "üöÄ Deployment to EC2 successful!"
          echo "API URL: http://${{ secrets.EC2_HOST }}:8000"
          echo "Documentation: http://${{ secrets.EC2_HOST }}:8000/docs"
        else
          echo "‚ùå Deployment failed. Check the logs for details."
        fi