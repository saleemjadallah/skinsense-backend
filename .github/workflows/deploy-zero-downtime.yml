name: Zero-Downtime Deploy to EC2

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Create deployment package
      run: |
        # Create temporary directory
        mkdir -p deployment
        
        # Copy necessary files
        cp -r app deployment/
        cp -r scripts deployment/ 2>/dev/null || mkdir -p deployment/scripts
        cp requirements.txt deployment/
        cp Dockerfile deployment/
        cp docker-compose.yml deployment/
        cp docker-compose.prod.yml deployment/ 2>/dev/null || true
        cp nginx.conf deployment/ 2>/dev/null || true
        cp .dockerignore deployment/
        
        # Check if critical secrets are set
        if [ -z "${{ secrets.MONGODB_URL }}" ]; then
          echo "‚ùå ERROR: MONGODB_URL secret is not set in GitHub!"
          exit 1
        fi
        
        # Create .env file with production secrets
        cat > deployment/.env << EOF
        APP_NAME="SkinSense AI"
        APP_VERSION="1.0.0"
        DEBUG=false
        MONGODB_URL=${{ secrets.MONGODB_URL }}
        DATABASE_NAME=skinpal
        REDIS_URL=redis://redis:6379
        SECRET_KEY=${{ secrets.SECRET_KEY }}
        ALGORITHM=HS256
        ACCESS_TOKEN_EXPIRE_MINUTES=60
        REFRESH_TOKEN_EXPIRE_DAYS=30
        ORBO_AI_API_KEY=${{ secrets.ORBO_AI_API_KEY }}
        ORBO_API_KEY=${{ secrets.ORBO_AI_API_KEY }}
        ORBO_CLIENT_ID=${{ secrets.ORBO_CLIENT_ID }}
        ORBO_CLIENTID=${{ secrets.ORBO_CLIENT_ID }}
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        PERPLEXITY_API_KEY=${{ secrets.PERPLEXITY_API_KEY }}
        AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION=${{ secrets.AWS_REGION }}
        S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}
        CLOUDFRONT_DOMAIN=${{ secrets.CLOUDFRONT_DOMAIN }}
        ZEPTOMAIL_SEND_TOKEN=${{ secrets.ZEPTOMAIL_SEND_TOKEN }}
        ZEPTOMAIL_HOST=api.zeptomail.com
        ZEPTOMAIL_DOMAIN=skinsense.app
        FIREBASE_PROJECT_ID=${{ secrets.FIREBASE_PROJECT_ID }}
        FIREBASE_SERVICE_ACCOUNT_PATH=/app/credentials/firebase-service-account.json
        PROMETHEUS_URL=http://prometheus:9090
        GRAFANA_URL=http://grafana:3001
        EOF
        
        # Create Firebase credentials if provided
        if [ ! -z "${{ secrets.FIREBASE_SERVICE_ACCOUNT }}" ]; then
          mkdir -p deployment/credentials
          echo "${{ secrets.FIREBASE_SERVICE_ACCOUNT }}" | base64 -d > deployment/credentials/firebase-service-account.json
        fi
        
        # Create tarball
        tar -czf deployment.tar.gz -C deployment .
    
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_KEY }}" | base64 -d > ~/.ssh/ec2_key.pem
        chmod 600 ~/.ssh/ec2_key.pem
        ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
    
    - name: Copy deployment package to EC2
      run: |
        echo "üì¶ Copying deployment package to EC2..."
        scp -i ~/.ssh/ec2_key.pem deployment.tar.gz ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:~/deployment.tar.gz
    
    - name: Deploy with Zero-Downtime Strategy
      run: |
        ssh -i ~/.ssh/ec2_key.pem ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENDSSH'
        echo "üöÄ Starting zero-downtime deployment..."
        
        # Verify deployment package exists
        if [ ! -f ~/deployment.tar.gz ]; then
          echo "‚ùå Deployment package not found!"
          exit 1
        fi
        
        # Set project name
        PROJECT_NAME="skinsense-backend"
        
        # Create deployment directory if it doesn't exist
        mkdir -p ~/skinsense-backend-new
        cd ~/skinsense-backend-new
        
        # Extract deployment package
        echo "üì¶ Extracting deployment package..."
        tar -xzf ~/deployment.tar.gz
        
        # Verify extraction was successful
        if [ ! -f docker-compose.yml ]; then
          echo "‚ùå docker-compose.yml not found after extraction!"
          ls -la
          exit 1
        fi
        
        # Clean up tarball
        rm ~/deployment.tar.gz
        
        # Verify docker-compose.yml exists
        if [ ! -f docker-compose.yml ]; then
          echo "‚ùå docker-compose.yml not found!"
          exit 1
        fi
        
        echo "‚úÖ docker-compose.yml found"
        
        # ZERO-DOWNTIME DEPLOYMENT STRATEGY
        echo "üîÑ Starting zero-downtime deployment..."
        
        # Step 1: Build new images without stopping old containers
        echo "üì¶ Building new Docker images..."
        docker-compose -p ${PROJECT_NAME}-new build --no-cache
        
        # Step 2: Check if old deployment exists
        if [ -d ~/skinsense-backend ] && docker ps | grep -q "$PROJECT_NAME"; then
          echo "üìä Old deployment is running, preparing for seamless switch..."
          
          # Step 3: Start new containers with different project name
          echo "üöÄ Starting new containers alongside old ones..."
          docker-compose -p ${PROJECT_NAME}-new up -d
          
          # Step 4: Wait for new containers to be healthy
          echo "‚è≥ Waiting for new containers to be healthy..."
          HEALTH_CHECK_ATTEMPTS=30
          HEALTH_CHECK_PASSED=false
          
          for i in $(seq 1 $HEALTH_CHECK_ATTEMPTS); do
            echo "Health check attempt $i of $HEALTH_CHECK_ATTEMPTS..."
            
            # Check if new API container is healthy via internal Docker network
            if docker exec ${PROJECT_NAME}-new-api-1 curl -s http://localhost:8000/health > /dev/null 2>&1; then
              echo "‚úÖ New API container is healthy!"
              HEALTH_CHECK_PASSED=true
              break
            else
              echo "Waiting for new container to be ready..."
              sleep 5
            fi
          done
          
          if [ "$HEALTH_CHECK_PASSED" = true ]; then
            echo "‚úÖ New deployment is healthy!"
            
            # Step 5: Update nginx/load balancer to point to new containers
            # Since we're using port 8000 directly, we need to switch ports
            echo "üîÑ Switching traffic to new deployment..."
            
            # Stop old containers
            echo "üì¶ Stopping old containers..."
            cd ~/skinsense-backend 2>/dev/null && docker-compose -p $PROJECT_NAME down || true
            
            # Rename new deployment to production
            cd ~/skinsense-backend-new
            docker-compose -p ${PROJECT_NAME}-new down
            
            # Start with production project name
            docker-compose -p $PROJECT_NAME up -d
            
            # Move directories
            if [ -d ~/skinsense-backend ]; then
              mv ~/skinsense-backend ~/skinsense-backend-old-$(date +%Y%m%d_%H%M%S)
            fi
            mv ~/skinsense-backend-new ~/skinsense-backend
            
            echo "‚úÖ Traffic switched to new deployment!"
          else
            echo "‚ùå New deployment health check failed, rolling back..."
            docker-compose -p ${PROJECT_NAME}-new down
            cd ~
            rm -rf ~/skinsense-backend-new
            exit 1
          fi
        else
          echo "üì¶ No old deployment found, starting fresh..."
          
          # Start containers normally
          docker-compose -p $PROJECT_NAME up -d
          
          # Move to production directory
          cd ~
          if [ -d ~/skinsense-backend ]; then
            mv ~/skinsense-backend ~/skinsense-backend-old-$(date +%Y%m%d_%H%M%S)
          fi
          mv ~/skinsense-backend-new ~/skinsense-backend
          
          # Health check
          echo "üè• Running health check..."
          sleep 20
          
          HEALTH_CHECK_ATTEMPTS=10
          HEALTH_CHECK_PASSED=false
          
          for i in $(seq 1 $HEALTH_CHECK_ATTEMPTS); do
            echo "Health check attempt $i of $HEALTH_CHECK_ATTEMPTS..."
            
            HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health 2>/dev/null || echo "000")
            
            if [ "$HEALTH_RESPONSE" = "200" ] || [ "$HEALTH_RESPONSE" = "503" ]; then
              echo "‚úÖ API is responding (HTTP $HEALTH_RESPONSE)!"
              HEALTH_CHECK_PASSED=true
              break
            else
              echo "Waiting for API to be ready..."
              sleep 10
            fi
          done
          
          if [ "$HEALTH_CHECK_PASSED" = false ]; then
            echo "‚ö†Ô∏è Health check did not pass, but checking if services are running..."
            if docker ps | grep -q "$PROJECT_NAME"; then
              echo "‚úÖ Services are running!"
            else
              echo "‚ùå Deployment failed!"
              exit 1
            fi
          fi
        fi
        
        # Cleanup old backups (keep last 3)
        echo "üóëÔ∏è Cleaning up old deployments..."
        ls -dt ~/skinsense-backend-old-* 2>/dev/null | tail -n +4 | xargs -r rm -rf
        
        # Final status
        echo "üìä Final deployment status:"
        cd ~/skinsense-backend
        docker-compose -p $PROJECT_NAME ps
        
        echo ""
        echo "üéâ Zero-downtime deployment successful!"
        echo "üìå Deployment Information:"
        echo "   API URL: http://${{ secrets.EC2_HOST }}:8000"
        echo "   Health: http://${{ secrets.EC2_HOST }}:8000/health"
        echo "   Docs: http://${{ secrets.EC2_HOST }}:8000/docs"
        ENDSSH
    
    - name: Clean up
      if: always()
      run: |
        rm -f ~/.ssh/ec2_key.pem
        rm -f deployment.tar.gz
        rm -rf deployment/
    
    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "üöÄ Zero-downtime deployment to EC2 successful!"
          echo "API URL: http://${{ secrets.EC2_HOST }}:8000"
          echo "Documentation: http://${{ secrets.EC2_HOST }}:8000/docs"
        else
          echo "‚ùå Deployment failed. Check the logs for details."
        fi